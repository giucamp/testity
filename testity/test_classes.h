
//   Copyright Giuseppe Campana (giu.campana@gmail.com) 2016.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#pragma once
#include <string>
#include <chrono>
#include <stdint.h>
#include <random>
#include <string>
#include "testity_common.h"

namespace testity
{
    enum class FeatureKind
    {
        Deleted,
        Supported,
        SupportedNoExcept
    };

    enum class Polymorphic
    {
        Yes,
        No
    };

    namespace detail
    {
        void random_storage_init(unsigned char * i_dest, size_t i_size) noexcept;
        void random_storage_init(unsigned char * i_dest, size_t i_size, int i_seed) noexcept;
        void random_storage_mark_moved_from(unsigned char * i_dest, size_t i_size) noexcept;
        void random_storage_mark_deleted(unsigned char * i_dest, size_t i_size) noexcept;
        bool random_storage_equals(const unsigned char * i_first, const unsigned char * i_second, size_t i_size) noexcept;
        size_t random_storage_hash(const unsigned char * i_dest, size_t i_size) noexcept;

        template <size_t SIZE>
            struct RandomStorage
        {
        public:

            RandomStorage() noexcept
            {
                random_storage_init(m_data, SIZE);
            }

            RandomStorage(int i_seed) noexcept
            {
                random_storage_init(m_data, SIZE, i_seed);
            }

            RandomStorage(const RandomStorage &) noexcept = default;
            RandomStorage & operator = (const RandomStorage &) noexcept = default;

            RandomStorage(RandomStorage && i_source) noexcept
                : RandomStorage(i_source) // call the copy constructor
            {
                random_storage_mark_moved_from(i_source.m_data, SIZE);
            }

            RandomStorage & operator = (RandomStorage &&) noexcept
            {
                *this = i_source; // call the copy assignment
                random_storage_mark_moved_from(i_source.m_data, SIZE);
            }

            bool operator == (const RandomStorage & i_other) const
            {
                return random_storage_equals(m_data, i_other.m_data, SIZE);
            }

            bool operator != (const RandomStorage & i_other) const
            {
                return !random_storage_equals(m_data, i_other.m_data, SIZE);
            }

            ~RandomStorage()
            {
                random_storage_mark_deleted(m_data, SIZE);
            }

            size_t hash() const noexcept
            {
                return random_storage_hash(m_data, SIZE);
            }

        private:
            unsigned char m_data[SIZE];
        };
    }

    template <
        FeatureKind DEFAULT_CONSTRUCTOR_SUPPORT,
        FeatureKind COPY_SUPPORT,
        FeatureKind MOVE_SUPPORT,
        size_t SIZE = alignof(std::max_align_t),
        size_t ALIGNMENT = alignof(std::max_align_t),
        Polymorphic POLYMORPHIC = Polymorphic::No >
            class TestClass;

    // warning: the following 54 partial specialization were generated by the program TestClassGen

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Deleted, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Deleted, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Deleted, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Deleted, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Deleted, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Deleted, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Supported, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Supported, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Supported, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Supported, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Supported, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Supported, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::SupportedNoExcept, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::SupportedNoExcept, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::SupportedNoExcept, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::SupportedNoExcept, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Deleted, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Deleted, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Deleted, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Deleted, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Deleted, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Deleted, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Supported, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Supported, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Supported, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Supported, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Supported, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Supported, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::SupportedNoExcept, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::SupportedNoExcept, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::SupportedNoExcept, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::SupportedNoExcept, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Deleted, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Deleted, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Deleted, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Deleted, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Deleted, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Deleted, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Supported, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Supported, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Supported, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Supported, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Supported, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Supported, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, FeatureKind::Deleted, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, FeatureKind::Supported, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::No > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT, Polymorphic::Yes > : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // virtual destructor
        virtual ~TestClass() noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    // warning: the above 54 partial specialization were generated by the program TestClassGen - END

    namespace detail
    {
        template < FeatureKind DEFAULT_CONSTRUCTOR_SUPPORT, FeatureKind COPY_SUPPORT, FeatureKind MOVE_SUPPORT, size_t /*SIZE*/ = alignof(std::max_align_t), size_t ALIGNMENT = alignof(std::max_align_t) >
            class TestBase1 : public TestClass<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, sizeof(std::max_align_t) * 4, ALIGNMENT, Polymorphic::Yes>
        {
        private:
            std::string m_str1 = "abc";

            using Base = TestClass<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, sizeof(std::max_align_t) * 4, ALIGNMENT, Polymorphic::Yes>;

        public:
            TestBase1() = default;

            TestBase1(int i_seed) : Base(i_seed) {}

            // comparison
            bool operator == (const TestBase1 & i_other) const
            {
                return Base::operator == (i_other);
            }
            bool operator != (const TestBase1 & i_other) const
            {
                return Base::operator != (i_other);
            }
        };

        template < FeatureKind DEFAULT_CONSTRUCTOR_SUPPORT, FeatureKind COPY_SUPPORT, FeatureKind MOVE_SUPPORT, size_t SIZE = alignof(std::max_align_t), size_t ALIGNMENT = alignof(std::max_align_t) >
            class TestBase2 : public TestClass<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT, Polymorphic::Yes>
        {
        private:
            int m_int = 42;
            std::string m_str2 = "abc";

            using Base = TestClass<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT, Polymorphic::Yes>;

        public:
            TestBase2() = default;

            TestBase2(int i_seed) : Base(i_seed ^ 3231) {}

            // comparison
            bool operator == (const TestBase2 & i_other) const
            {
                return Base::operator == (i_other);
            }
            bool operator != (const TestBase2 & i_other) const
            {
                return Base::operator != (i_other);
            }
        };

        template < FeatureKind DEFAULT_CONSTRUCTOR_SUPPORT, FeatureKind COPY_SUPPORT, FeatureKind MOVE_SUPPORT, size_t SIZE = alignof(std::max_align_t), size_t ALIGNMENT = alignof(std::max_align_t) >
            class TestBase1_VirtualBase : public virtual TestClass<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT, Polymorphic::Yes>
        {
        private:
            std::string m_str1 = "abc";

            using Base = TestClass<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT, Polymorphic::Yes>;

        public:
            TestBase1_VirtualBase() = default;

            TestBase1_VirtualBase(int i_seed) : Base(i_seed ^ 223) {}

            // comparison
            bool operator == (const TestBase1_VirtualBase & i_other) const
            {
                return Base::operator == (i_other);
            }
            bool operator != (const TestBase1_VirtualBase & i_other) const
            {
                return Base::operator != (i_other);
            }
        };

        template < FeatureKind DEFAULT_CONSTRUCTOR_SUPPORT, FeatureKind COPY_SUPPORT, FeatureKind MOVE_SUPPORT, size_t SIZE = alignof(std::max_align_t), size_t ALIGNMENT = alignof(std::max_align_t) >
            class TestBase2_VirtualBase : public virtual TestClass<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT, Polymorphic::Yes>
        {
        private:
            int m_int = 42;
            std::string m_str2 = "abc";

            using Base = TestClass<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT, Polymorphic::Yes>;

        public:
            TestBase2_VirtualBase() = default;

            TestBase2_VirtualBase(int i_seed) : Base(i_seed) {}
			
            // comparison
            bool operator == (const TestBase2_VirtualBase & i_other) const
            {
                return Base::operator == (i_other);
            }
            bool operator != (const TestBase2_VirtualBase & i_other) const
            {
                return Base::operator != (i_other);
            }
        };

    } // detail

    template < FeatureKind DEFAULT_CONSTRUCTOR_SUPPORT, FeatureKind COPY_SUPPORT, FeatureKind MOVE_SUPPORT, size_t SIZE = alignof(std::max_align_t), size_t ALIGNMENT = alignof(std::max_align_t) >
        class MultipleInheriTestClass :
            private detail::TestBase1<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT>,
            public detail::TestBase2<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT>
    {
    private:
        double m_int2 = 42.0;
        std::string m_str3 = "abc";

    public:
        MultipleInheriTestClass() = default;

        MultipleInheriTestClass(int i_seed) :
            detail::TestBase1<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT>(i_seed),
            detail::TestBase2<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT>(i_seed)
                { }
		
        size_t hash() const noexcept
        {
            return detail::TestBase1<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT>::hash()
                ^ detail::TestBase2<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT>::hash();
        }

        // comparison
        bool operator == (const MultipleInheriTestClass & i_other) const
        {
            return detail::TestBase1<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT>::operator == (i_other)
                && detail::TestBase2<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT>::operator == (i_other);
        }
        bool operator != (const MultipleInheriTestClass & i_other) const
        {
            return detail::TestBase1<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT>::operator != (i_other)
                || detail::TestBase2<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT>::operator != (i_other);
        }
    };

    template < FeatureKind DEFAULT_CONSTRUCTOR_SUPPORT, FeatureKind COPY_SUPPORT, FeatureKind MOVE_SUPPORT, size_t SIZE = alignof(std::max_align_t), size_t ALIGNMENT = alignof(std::max_align_t) >
        class MultipleVirtualInheriTestClass :
            public virtual detail::TestBase1_VirtualBase<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT>,
            public virtual TestClass<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT, Polymorphic::Yes>,
            public virtual detail::TestBase2_VirtualBase<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT>
    {
    private:
        double m_int2 = 42.0;
        std::string m_str3 = "abc";

        using Base1 = detail::TestBase1_VirtualBase<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT>;
        using Base2 = TestClass<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT, Polymorphic::Yes>;
        using Base3 = detail::TestBase2_VirtualBase<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT>;

    public:

        MultipleVirtualInheriTestClass() = default;

		MultipleVirtualInheriTestClass(int i_seed)
			: Base1(i_seed), Base2(i_seed * 7), Base3(i_seed * 11) { }

        size_t hash() const noexcept
        {
            return Base1::hash() ^ Base2::hash() ^ Base3::hash();
        }

        // comparison
        bool operator == (const MultipleVirtualInheriTestClass & i_other) const
        {
            return Base1::operator == (i_other) && Base2::operator == (i_other) && Base3::operator == (i_other);
        }
        bool operator != (const MultipleVirtualInheriTestClass & i_other) const
        {
            return Base1::operator != (i_other) || Base2::operator != (i_other) || Base3::operator != (i_other);
        }
    };

    using UnmovableTestClass = TestClass<FeatureKind::Supported, FeatureKind::Deleted, FeatureKind::Deleted, 32>;
    using UniqueTestClass = TestClass<FeatureKind::Supported, FeatureKind::Deleted, FeatureKind::SupportedNoExcept, 32>;
    using CopyableTestClass = TestClass<FeatureKind::Supported, FeatureKind::Supported, FeatureKind::SupportedNoExcept, 32>;

    template < FeatureKind DEFAULT_CONSTRUCTOR_SUPPORT, FeatureKind COPY_SUPPORT, FeatureKind MOVE_SUPPORT, size_t SIZE = alignof(std::max_align_t), size_t ALIGNMENT = alignof(std::max_align_t), Polymorphic POLYMORPHIC >
        inline size_t hash_func(const TestClass<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT, POLYMORPHIC> & i_object) noexcept
    {
        return i_object.hash();
    }

    template < FeatureKind DEFAULT_CONSTRUCTOR_SUPPORT, FeatureKind COPY_SUPPORT, FeatureKind MOVE_SUPPORT, size_t SIZE = alignof(std::max_align_t), size_t ALIGNMENT = alignof(std::max_align_t) >
        inline size_t hash_func(const MultipleInheriTestClass<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT> & i_object) noexcept
    {
        return i_object.hash();
    }

    template < FeatureKind DEFAULT_CONSTRUCTOR_SUPPORT, FeatureKind COPY_SUPPORT, FeatureKind MOVE_SUPPORT, size_t SIZE = alignof(std::max_align_t), size_t ALIGNMENT = alignof(std::max_align_t) >
        inline size_t hash_func(const MultipleVirtualInheriTestClass<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT> & i_object) noexcept
    {
        return i_object.hash();
    }
}
